!!!!THIS IS AN EXPERMENT!!!!!!
!!!DO NOT USE IN PRODUCTION!!!


vTTYs are built to replace the autovt@.service with vtty-frontend@.service
vtty-frontend@.service assumes seat0, and the parameter is the vt name (for example: tty1)

  vtty-frontend@.service depends on vtty-backend@.service to where vtty-frontend@{INSTANCE}.service has systemd start vtty-backend@{INSTANCE}.service
  vtty-backend@.service calls an instance of socat that launches an instance of getty in a PTY. It runs as root. Communication to this getty is done through the socat client through a socket file that the socat server creates. The socat server allows the 'vtty' system user to communicate to this socket

  vtty-frontend@.service runs as the 'vtty' user. It runs a display server, `cage` which starts the terminal emulator, `foot`, which then calls a small script that starts the socat client. This design gets around needing to call the cage display server, and foot terminal emulator as root.

  The small script traps SIGWINCH events, (terminal resize signal) to the backend though another FIFO. The backend listens on the FIFO for these events. On an event, the PTY size of foot is sent though the FIFO, and the backend script sets the PTY size of the backend one that socat starts. By doing so, text mode programs, like nmtui appear correctly.
  
  The vtty-toggle command allows fallback to a VT console. It requires to be run as root.

  User session's XDG_SEAT is seat to seat-vtty. seat-vtty is created by making a device that exists on all systems (/dev/tty the alias device for the current terminal, it exists even when CONFIG_VT=n) have the master-of-seat tag, and then assigns it to seat-vtty so logind creates the seat-vtty seat. 
  
  The reasons for this are
    Only one session can be active on a session at the a time, but here, there are two, the session created by Cage, and the session running under socat. If logind has the session that runs under socat as active, instead of the session for cage, cage becomes inactive.
  
    Another reason is that there can only be one session on a TTY. And on seat0 when VTs are compiled in the kernel, for a PAM session to be complete, it needs a TTY
  
  Creating a "fake" seat, and starting sessions gets around these issues. Non-seat0 seats don't need VTs, so seat-vtty fits. 

  This allows logins to have full PAM sessions to where actions that require polkit don't require the user to authenticate twice, the same as a Desktop session, or a session in a normal VT. (such as actions from nmtui, etc.)

vtty-frontend-novt@.service works very similar, but the parameter is the seat. Because systemd only accepts one parameter, there can only be one instance on a seat. This is for seats without VTs. (as in non-seat0 seats, or where the kernel is compiled with CONFIG_VT=n)


  The way that the services work is very similar to vTTYs, except that the instance name is the seat name instead of a VT name.
  This is suited for more minimal installs that are mostly headless without VTs. 
  For multiple instances, its better if a proper display manager or login manager is used.

  if display-manager.service is disabled, and vtty-frontend-novt@seat0.service is enabled, VT-less systems will start up to a text mode login prompt.


UvTTYs are built similar to vTTYs, only they run as a user.
  Instead of running as root, to launch a getty, the backend runs as the user, and launches the user's shell.

  They can be registered as a selectable wayland-session because cage is a Wayland display server.

  The client/server design for this is for resillency instead of separation of permissions. 
  
  The main reason for this is for the uvtty-launch command. uvtty-launch quits and supresses the frontend from starting cage, so that another display server can take over. such as running `uvtty-launch weston`. 
  
  The shell continues to run in the socat 'server'. Once Weston quits, uvtty-launch allows cage to start back up again.
  This does not require to be run as root


Problems:

  - cage/foot not actually packaged by Debian yet.
